# Service Mesh Generator
The ServiceMeshGenerator (`RunServiceMeshGen.py`) generates a .json file that descibes the service mesh of the Microservice Application.

## Service Mesh Topology
Litterature [studies](https://researchcommons.waikato.ac.nz/bitstream/handle/10289/13981/EVOKE_CASCON_2020_paper_37_WeakestLink.pdf?sequence=11&isAllowed=y) show that the building of a realistic mesh can be done by using the Barab√°si-Albert (BA) algorithm, which uses a power-law distribution and results in a topology that follows a preferential-attachment model. For this reason we chose to model the service mesh as a BA graph.
If we change the values of the BA model, we are able to genereate microservice applications with different mesh topologies. 

The BA algorithm builds the mesh topology as follows: at each step a new service is added as a vertex of a directed tree. This new service is connected with an edge to a single *parent* service already present in the topology. The edge direction is from the parent service to the new *child* service, this means that the parent service includes the new service in its external-services.  
The parent service is chosen according to a preferred attachment strategy using a power-law distribution. Specifically, vertex *i* is chosen as a parent with a (non-normalized) probability equal to *Pi = di^aplha+a*, where *di* is the number of services that have already chosen the service *i* as a parent, *alpha* is the power-law exponent, and *a* is the zero-appeal parameters i.e., the probability of a service being chosen as a parent when no other service has yet chosen it.

## External Service Grouping
To simulate parallel and sequential calls of external-services, the whole set of external-services of a service is organized in a number of `external_service_groups`. Each group contains a different set of external-services and the insertion of external-services in groups is made according to a water-filling algorithm.

## Service execution
When a service request is received, a service executes its internal-service and then the external-services contained in the external-service groups. For each group, a dedicated thread randomly selects `seq_len` external-services from it and invokes (e.g., HTTP call) them sequentially. These threads are executed in parallel, one per group. If the number of external services is less than the configured number of service groups, some service groups do not exist and existing groups contain only a single external-service (water-filling). If the number of external-services in a group is lower than `seq_len`, all external-services in the service group are invoked sequentially. 

## Databases
To simulate the presence of databases in the microservice application, we added to the above topology some *database-services* that only execute their internal service. Other simple services, select one of these databases with a configurable probability.     

## Output Undersanding
This is an example of the `servicemesh.json` file generated by the Service Mesh Generator. The related mesh is shown in the .png figure


<img align="right" width="270" src="servicemesh-demo.png">

There are ten services (no databases), `external_service_groups` =2 and `seq_len`= 2. The services have an ID equal to `s{service-number}` (databases too). Each service is a key in the JSON, the value of which is an array. An element of the array describes a group of external-services. In this case, service s0 has five external-services (children) distributed in two groups. The first is composed of services s1,s4,s9; the second, of services s2,s5. Some services are teminal, that is, they do not call any external service, as in the case of services s5,s6,s7,s8,s9.    

```json
{'s0': [{'seq_len': 2, 'services': ['s1', 's4', 's9']},
        {'seq_len': 2, 'services': ['s2', 's5']}],
 's1': [{'seq_len': 2, 'services': ['s3']}, {'seq_len': 2, 'services': ['s6']}],
 's2': [],
 's3': [{'seq_len': 2, 'services': ['s7']}],
 's4': [{'seq_len': 2, 'services': ['s8']}],
 's5': [],
 's6': [],
 's7': [],
 's8': [],
 's9': []}
```

---
## Install requirements
First, install the requirements using ``pip3``:

```zsh
pip3 install -r requirements.txt
```

## Input parameters
Next, edit the values of the keys in ``ServiceMeshParameters.json`` before running the ``RunServiceMeshGen.py`` that actually generates the mesh files (servicemesh.json and servicemesh.png). The meaning of the keys is:

* `vertices` are the number of services that forms the microservice application (databases excluded, more later)
* `power` is the exponent of the power-law distribution used by the BA algorithm
* `zero_appeal` is the zero-appeal parameter used by the BA algorithm
* `external_service_groups` is the number of external-service groups  
* `dbs` is used to specify the properies of databases. You can specify a list of db names followed by the probability it can be chosen by the services.
Three possible examples are:
    1. `"dbs": {}` there are no db services inside the mesh 
    2. `"dbs": {"sdb1": 0.4, "sdb2": 0.6, "sdb3": 0.2}` every service is attached to one of the listed dbs with  probability 0.4 for sdb1, 0.6 for sdb2 and 0.2 for sdb3 (the probabilities will be normalized in any case)
    3. `"dbs": {"nodb": 0.6, "sdb1": 0.2, "sdb2": 0.1, "sdb3": 0.1, ...}` similar to the previous example but with the possibility that a service can be no attached to any db with the `nodb` probability.

---
## Examples
Now, we illustrate four examples of different service mesh topologies:

* An highly-centralized hierarchical architectures with most of the services linked to one service (exluded the db services):

```json
{
    "external_service_groups": 1, 
    "vertices": 10, 
    "power": 0.05,
    "zero_appeal": 0.01,
    "dbs": {"nodb": 0.2, "sdb1": 0.6, "sdb2": 0.4}
}
```

<img width="400" src="../Docs/service_mesh_example_1.png">

*  An applications that rely on a common logging service


```json
{
    "external_service_groups": 1, 
    "vertices": 10, 
    "power": 0.9,
    "zero_appeal": 0.01,
    "dbs": {"nodb": 0.2, "sdb1": 0.6, "sdb2": 0.4}
}
```

<img width="400" src="../Docs/service_mesh_example_2.png">

* An application with several auxiliary services:


```json
{
    "external_service_groups": 1,
    "vertices": 10, 
    "power": 0.05, 
    "zero_appeal": 3.25,
    "dbs": {"nodb": 0.2, "sdb1": 0.6, "sdb2": 0.4}
}
```

<img width="400" src="../Docs/service_mesh_example_3.png">

* An application organized in the conventional multi-tier fashion:

```json
{
    "external_service_groups": 1, 
    "vertices": 10, 
    "power": 0.9,  
    "zero_appeal": 3.25,
    "dbs": {"nodb": 0.2, "sdb1": 0.6, "sdb2": 0.4}
}
```

<img width="400" src="../Docs/service_mesh_example_4.png">


---
## Run the script
Finally, to run only the ServiceMeshGenerator, run the script to obtain `servicemesh.json` and `servicemesh.png`:

```zsh
python3 RunServiceMeshGen.py
```